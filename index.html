<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rummikub Game Simulator</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            padding: 20px 0;
            margin-bottom: 30px;
        }
        
        h1 {
            font-size: 2.8rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        button {
            background: linear-gradient(to bottom, #ff9a00, #ff6a00);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1rem;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            background: linear-gradient(to bottom, #ffaa20, #ff7a20);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .game-area {
            display: grid;
            grid-template-columns: 1fr;
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .section {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .section-title {
            font-size: 1.4rem;
            margin-bottom: 15px;
            color: #ffcc00;
            border-bottom: 2px solid #ffcc00;
            padding-bottom: 8px;
        }
        
        .player-area {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
        
        .player {
            background: rgba(30, 30, 60, 0.7);
            border-radius: 12px;
            padding: 15px;
            position: relative;
            border: 2px solid transparent;
            transition: border-color 0.3s;
        }
        
        .player.ice-broken {
            border-color: #66ff66;
            box-shadow: 0 0 15px rgba(102, 255, 102, 0.5);
        }
        
        .player.current-turn {
            animation: pulse 2s infinite;
            box-shadow: 0 0 0 4px rgba(255, 204, 0, 0.5);
        }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 204, 0, 0.7); }
            70% { box-shadow: 0 0 0 12px rgba(255, 204, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 204, 0, 0); }
        }
        
        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .player-name {
            font-size: 1.3rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .ice-icon {
            color: #66ff66;
            font-size: 1.2em;
        }
        
        .player-score {
            background: #ff6a00;
            border-radius: 20px;
            padding: 5px 15px;
            font-weight: bold;
        }
        
        .tiles {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            min-height: 80px;
        }
        
        .tile {
            width: 50px;
            height: 65px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 1.2rem;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.4);
            position: relative;
            overflow: hidden;
            transition: transform 0.2s;
            cursor: pointer;
        }
        
        .tile:hover {
            transform: translateY(-5px);
        }
        
        .tile.red { background: linear-gradient(to bottom, #ff4d4d, #cc0000); }
        .tile.blue { background: linear-gradient(to bottom, #4d79ff, #0040cc); }
        .tile.yellow { background: linear-gradient(to bottom, #ffff4d, #cccc00); color: #333; }
        .tile.black { background: linear-gradient(to bottom, #666666, #000000); }
        .tile.joker { 
            background: linear-gradient(to bottom, #9b59b6, #8e44ad);
            animation: jokerGlow 2s infinite;
        }
        
        @keyframes jokerGlow {
            0% { box-shadow: 0 0 5px rgba(155, 89, 182, 0.7); }
            50% { box-shadow: 0 0 15px rgba(155, 89, 182, 0.9); }
            100% { box-shadow: 0 0 5px rgba(155, 89, 182, 0.7); }
        }
        
        .tile-value {
            font-size: 1.5rem;
        }
        
        .tile-joker {
            font-size: 2.5rem;
            line-height: 1;
        }
        
        .table-area {
            min-height: 200px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
        }
        
        .table-sets {
            display: flex;
            flex-wrap: wrap;
            gap: 25px;
            justify-content: center;
        }
        
        .set {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            min-width: 200px;
            position: relative;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .set-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .set-title {
            font-size: 1.1rem;
            color: #66ff66;
        }
        
        .set-points {
            background: rgba(255, 204, 0, 0.3);
            border-radius: 15px;
            padding: 3px 10px;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        .set-tiles {
            display: flex;
            gap: 8px;
            justify-content: center;
        }
        
        .joker-replacement {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #ffcc00;
            color: #333;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        
        .log-container {
            height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            font-family: monospace;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            line-height: 1.4;
        }
        
        .log-time {
            color: #ffcc00;
            margin-right: 10px;
        }
        
        .status-bar {
            text-align: center;
            padding: 15px;
            font-size: 1.2rem;
            font-weight: bold;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            margin-top: 20px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .icebreaker-indicator {
            background: rgba(102, 255, 102, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-left: 10px;
        }
        
        .joker-indicator {
            background: rgba(155, 89, 182, 0.3);
            padding: 8px 15px;
            border-radius: 20px;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            margin-left: 10px;
        }
        
        .strategy-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .strategy-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 15px;
            transition: transform 0.3s;
        }
        
        .strategy-card:hover {
            transform: translateY(-5px);
            background: rgba(255, 255, 255, 0.15);
        }
        
        .strategy-card h3 {
            color: #66ccff;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .rules-container {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .rules-title {
            font-size: 1.8rem;
            color: #ffcc00;
            margin-bottom: 20px;
            text-align: center;
            border-bottom: 2px solid #ffcc00;
            padding-bottom: 10px;
        }
        
        .rules-section {
            margin-bottom: 25px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 10px;
        }
        
        .rules-section h3 {
            color: #66ff66;
            margin-bottom: 12px;
            font-size: 1.4rem;
        }
        
        .rules-list {
            padding-left: 20px;
        }
        
        .rules-list li {
            margin-bottom: 10px;
            line-height: 1.5;
        }
        
        .joker-highlight {
            background: rgba(155, 89, 182, 0.15);
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 4px solid #9b59b6;
            margin: 15px 0;
            font-weight: bold;
        }
        
        .deck-info {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 0.9rem;
        }
        
        .no-sets {
            text-align: center;
            padding: 30px;
            font-style: italic;
            opacity: 0.7;
        }
        
        @media (max-width: 768px) {
            .player-area {
                grid-template-columns: 1fr;
            }
            
            .game-controls {
                flex-direction: column;
                align-items: center;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .tile {
                width: 40px;
                height: 55px;
                font-size: 1rem;
            }
            
            .tile-value {
                font-size: 1.2rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Rummikub Game Simulator</h1>
            <p class="subtitle">Official rules implementation with Joker card functionality</p>
        </header>
        
        <div class="game-controls">
            <button id="newGameBtn">New Game</button>
            <button id="dealTilesBtn">Deal Tiles</button>
            <button id="simulateBtn">Simulate Next Move</button>
            <button id="autoPlayBtn">Auto Play (5 Rounds)</button>
            <button id="resetBtn">Reset Game</button>
        </div>
        
        <div class="status-bar" id="statusBar">
            Welcome to Rummikub! Start a new game to begin.
        </div>
        
        <div class="game-area">
            <div class="section">
                <h2 class="section-title">Players & Tiles</h2>
                <div class="player-area" id="playerArea">
                    <!-- Player sections will be generated here -->
                </div>
            </div>
            
            <div class="section">
                <h2 class="section-title">Table Sets <span class="deck-info">Tiles left: <span id="tilesLeft">0</span></span></h2>
                <div class="table-area">
                    <div class="table-sets" id="tableSets">
                        <div class="no-sets">No sets on the table yet. Players must break the ice first!</div>
                    </div>
                </div>
            </div>
            
            <div class="section">
                <h2 class="section-title">Game Log</h2>
                <div class="log-container" id="gameLog">
                    <!-- Game logs will appear here -->
                </div>
            </div>
        </div>
        
        <div class="section">
            <h2 class="section-title">Joker Card Strategy</h2>
            <div class="strategy-info">
                <div class="strategy-card">
                    <h3>🃏 Joker Usage</h3>
                    <p>Jokers can substitute for any tile in a set. Players can replace table jokers with the actual tile if they have it.</p>
                </div>
                <div class="strategy-card">
                    <h3>🧊 Icebreaker Priority</h3>
                    <p>AI uses jokers strategically to complete high-value sets for the icebreaker requirement.</p>
                </div>
                <div class="strategy-card">
                    <h3>🔄 Joker Recovery</h3>
                    <p>Players can reclaim jokers from the table by replacing them with the actual tile they represent.</p>
                </div>
                <div class="strategy-card">
                    <h3>🎯 Strategic Placement</h3>
                    <p>Jokers are used in positions that allow for future expansion of sets.</p>
                </div>
            </div>
        </div>
        
        <div class="rules-container">
            <h2 class="rules-title">Official Rummikub Joker Rules</h2>
            
            <div class="rules-section">
                <h3>Joker Card Functionality</h3>
                <ul class="rules-list">
                    <li>Jokers can substitute for any tile in a set (run or group)</li>
                    <li class="joker-highlight">When a joker is on the table, a player can retrieve it by replacing it with the tile it represents from their hand</li>
                    <li>The player must use the joker immediately in the same turn to form a new valid set</li>
                    <li>Jokers count as 30 points if left in hand at game end</li>
                </ul>
            </div>
            
            <div class="rules-section">
                <h3>Icebreaker with Joker</h3>
                <ul class="rules-list">
                    <li>Jokers can be used in the initial 30+ point icebreaker set</li>
                    <li>The joker's value in a set is the value of the tile it represents</li>
                    <li>Players can use jokers to complete high-value sets when natural tiles are missing</li>
                </ul>
            </div>
            
            <div class="rules-section">
                <h3>Joker Replacement Rules</h3>
                <ul class="rules-list">
                    <li>To replace a joker in a run, the player must have the exact tile that fits in the sequence</li>
                    <li>To replace a joker in a group, the player must have the same number tile in a color not already in the group</li>
                    <li>After replacing the joker, the player must immediately use it to form a new valid set</li>
                </ul>
            </div>
            
            <div class="rules-section">
                <h3>End Game Scoring</h3>
                <ul class="rules-list">
                    <li>Jokers left in hand count as 30 penalty points</li>
                    <li>If a player goes out, other players sum their remaining tiles including jokers</li>
                    <li>The winner scores positive points equal to the sum of all opponents' tiles</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game state
            const state = {
                players: [
                    { name: 'Player 1', tiles: [], score: 0, isHuman: false, hasBrokenIce: false },
                    { name: 'Player 2', tiles: [], score: 0, isHuman: false, hasBrokenIce: false },
                    { name: 'Player 3', tiles: [], score: 0, isHuman: false, hasBrokenIce: false }
                ],
                tableSets: [],
                deck: [],
                currentPlayer: 0,
                gameStarted: false,
                gameLog: [],
                autoPlayInterval: null
            };
            
            // DOM Elements
            const playerArea = document.getElementById('playerArea');
            const tableSets = document.getElementById('tableSets');
            const gameLog = document.getElementById('gameLog');
            const statusBar = document.getElementById('statusBar');
            const tilesLeftEl = document.getElementById('tilesLeft');
            const newGameBtn = document.getElementById('newGameBtn');
            const dealTilesBtn = document.getElementById('dealTilesBtn');
            const simulateBtn = document.getElementById('simulateBtn');
            const autoPlayBtn = document.getElementById('autoPlayBtn');
            const resetBtn = document.getElementById('resetBtn');
            
            // Initialize the game
            function initGame() {
                createDeck();
                state.tableSets = [];
                state.currentPlayer = 0;
                state.gameStarted = false;
                state.gameLog = [];
                
                // Clear player tiles and reset icebreaker status
                state.players.forEach(player => {
                    player.tiles = [];
                    player.score = 0;
                    player.hasBrokenIce = false;
                });
                
                updateGameLog('Game initialized. Click "New Game" to start.');
                updateStatusBar('Ready to start a new game');
                renderGame();
            }
            
            // Create the deck of tiles
            function createDeck() {
                state.deck = [];
                const colors = ['red', 'blue', 'yellow', 'black'];
                const jokers = 2;
                
                // Create numbered tiles (2 of each number/color combination)
                for (let color of colors) {
                    for (let num = 1; num <= 13; num++) {
                        // Add two of each tile
                        state.deck.push({ number: num, color: color, isJoker: false });
                        state.deck.push({ number: num, color: color, isJoker: false });
                    }
                }
                
                // Add jokers
                for (let i = 0; i < jokers; i++) {
                    state.deck.push({ number: 0, color: 'joker', isJoker: true });
                }
                
                tilesLeftEl.textContent = state.deck.length;
            }
            
            // Shuffle the deck
            function shuffleDeck() {
                for (let i = state.deck.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [state.deck[i], state.deck[j]] = [state.deck[j], state.deck[i]];
                }
                tilesLeftEl.textContent = state.deck.length;
            }
            
            // Deal tiles to players
            function dealTiles() {
                if (!state.gameStarted) {
                    updateGameLog('Game not started. Please start a new game first.');
                    return;
                }
                
                // Deal 14 tiles to each player
                state.players.forEach(player => {
                    player.tiles = [];
                    player.hasBrokenIce = false; // Reset icebreaker status
                    for (let i = 0; i < 14; i++) {
                        if (state.deck.length > 0) {
                            player.tiles.push(state.deck.pop());
                        }
                    }
                    sortPlayerTiles(player);
                });
                
                tilesLeftEl.textContent = state.deck.length;
                updateGameLog('Tiles have been dealt to all players.');
                updateStatusBar(`Tiles dealt. It's ${state.players[state.currentPlayer].name}'s turn`);
                renderGame();
            }
            
            // Sort player tiles by color and number
            function sortPlayerTiles(player) {
                player.tiles.sort((a, b) => {
                    // Jokers at the end
                    if (a.isJoker) return 1;
                    if (b.isJoker) return -1;
                    
                    // Sort by color first
                    const colorOrder = { 'red': 1, 'blue': 2, 'yellow': 3, 'black': 4 };
                    if (colorOrder[a.color] !== colorOrder[b.color]) {
                        return colorOrder[a.color] - colorOrder[b.color];
                    }
                    
                    // Then by number
                    return a.number - b.number;
                });
            }
            
            // Draw a tile for the current player
            function drawTile(player) {
                if (state.deck.length > 0) {
                    const drawnTile = state.deck.pop();
                    player.tiles.push(drawnTile);
                    sortPlayerTiles(player);
                    tilesLeftEl.textContent = state.deck.length;
                    return drawnTile;
                }
                return null;
            }
            
            // Simulate a player's move
            function simulateMove() {
                if (!state.gameStarted) {
                    updateGameLog('Game not started. Please start a new game first.');
                    return;
                }
                
                if (state.deck.length === 0) {
                    updateGameLog('Deck is empty. Game over!');
                    clearInterval(state.autoPlayInterval);
                    endGame();
                    return;
                }
                
                const player = state.players[state.currentPlayer];
                updateGameLog(`${player.name}'s turn. Simulating strategy...`);
                
                // AI Strategy implementation
                setTimeout(() => {
                    let moveMade = false;
                    
                    // Strategy 1: Try to break the ice if not already done
                    if (!player.hasBrokenIce) {
                        moveMade = tryBreakIce(player);
                        if (moveMade) {
                            player.hasBrokenIce = true;
                            updateGameLog(`❄️ ${player.name} broke the ice with 30+ points! ❄️`);
                        } else {
                            // If couldn't break ice, must draw a tile
                            const drawnTile = drawTile(player);
                            if (drawnTile) {
                                updateGameLog(`${player.name} couldn't break the ice and draws a tile.`);
                                moveMade = true;
                            } else {
                                updateGameLog(`${player.name} couldn't break the ice and no tiles left to draw.`);
                            }
                        }
                    } else {
                        // Player has already broken the ice
                        
                        // Strategy 2: Try to replace a joker on the table
                        if (!moveMade) {
                            moveMade = tryReplaceJoker(player);
                        }
                        
                        // Strategy 3: Try to form a new set if possible
                        if (!moveMade) {
                            moveMade = tryFormNewSet(player);
                        }
                        
                        // Strategy 4: Try to add to existing sets
                        if (!moveMade) {
                            moveMade = tryAddToExistingSets(player);
                        }
                        
                        // Strategy 5: Try to form a group with high numbers
                        if (!moveMade) {
                            moveMade = tryFormHighGroup(player);
                        }
                        
                        // If no move was made, draw a tile
                        if (!moveMade) {
                            const drawnTile = drawTile(player);
                            if (drawnTile) {
                                updateGameLog(`${player.name} couldn't make a move and draws a tile.`);
                                moveMade = true;
                            } else {
                                updateGameLog(`${player.name} couldn't make a move and no tiles left to draw.`);
                            }
                        }
                    }
                    
                    // Check if player has won
                    if (player.tiles.length === 0) {
                        updateGameLog(`🎉 ${player.name} has played all their tiles and wins the game! 🎉`);
                        clearInterval(state.autoPlayInterval);
                        endGame();
                    }
                    
                    // Move to next player
                    state.currentPlayer = (state.currentPlayer + 1) % state.players.length;
                    updateStatusBar(`It's now ${state.players[state.currentPlayer].name}'s turn`);
                    renderGame();
                }, 800);
            }
            
            // Replace a joker on the table with the actual tile
            function tryReplaceJoker(player) {
                // Only try if player has broken the ice
                if (!player.hasBrokenIce) return false;
                
                // Look for sets with jokers on the table
                for (let setIndex = 0; setIndex < state.tableSets.length; setIndex++) {
                    const set = state.tableSets[setIndex];
                    
                    // Find joker position in the set
                    const jokerIndex = set.tiles.findIndex(tile => tile.isJoker);
                    if (jokerIndex === -1) continue;
                    
                    const joker = set.tiles[jokerIndex];
                    
                    if (set.type === 'run') {
                        // For runs: determine what tile the joker represents
                        let requiredTile = null;
                        
                        if (jokerIndex === 0) {
                            // Joker is at the beginning
                            const nextTile = set.tiles[1];
                            requiredTile = {
                                number: nextTile.number - 1,
                                color: nextTile.color,
                                isJoker: false
                            };
                        } else if (jokerIndex === set.tiles.length - 1) {
                            // Joker is at the end
                            const prevTile = set.tiles[jokerIndex - 1];
                            requiredTile = {
                                number: prevTile.number + 1,
                                color: prevTile.color,
                                isJoker: false
                            };
                        } else {
                            // Joker is in the middle
                            const prevTile = set.tiles[jokerIndex - 1];
                            const nextTile = set.tiles[jokerIndex + 1];
                            if (nextTile.number - prevTile.number === 2) {
                                requiredTile = {
                                    number: prevTile.number + 1,
                                    color: prevTile.color,
                                    isJoker: false
                                };
                            }
                        }
                        
                        if (requiredTile) {
                            // Check if player has the required tile
                            const playerTileIndex = player.tiles.findIndex(tile => 
                                !tile.isJoker && 
                                tile.number === requiredTile.number && 
                                tile.color === requiredTile.color
                            );
                            
                            if (playerTileIndex !== -1) {
                                const playerTile = player.tiles[playerTileIndex];
                                
                                // Replace joker with actual tile
                                set.tiles[jokerIndex] = { ...playerTile };
                                player.tiles.splice(playerTileIndex, 1);
                                
                                // Add joker to player's tiles temporarily
                                player.tiles.push(joker);
                                sortPlayerTiles(player);
                                
                                // Try to use the joker immediately
                                let jokerUsed = tryFormNewSetWithJoker(player, joker) || 
                                                tryAddToExistingSetsWithJoker(player, joker);
                                
                                if (jokerUsed) {
                                    updateGameLog(`🃏 ${player.name} replaced a joker with ${playerTile.number}${getColorSymbol(playerTile.color)} and used the joker!`);
                                    return true;
                                } else {
                                    // Couldn't use joker - revert changes
                                    set.tiles[jokerIndex] = joker;
                                    player.tiles = player.tiles.filter(t => t !== joker);
                                    player.tiles.push(playerTile);
                                    sortPlayerTiles(player);
                                }
                            }
                        }
                    } else if (set.type === 'group') {
                        // For groups: joker can be replaced with any missing color
                        const groupNumber = set.tiles.find(t => !t.isJoker).number;
                        const existingColors = new Set(set.tiles.filter(t => !t.isJoker).map(t => t.color));
                        const allColors = ['red', 'blue', 'yellow', 'black'];
                        const missingColors = allColors.filter(color => !existingColors.has(color));
                        
                        for (let color of missingColors) {
                            // Check if player has tile with same number and missing color
                            const playerTileIndex = player.tiles.findIndex(tile => 
                                !tile.isJoker && 
                                tile.number === groupNumber && 
                                tile.color === color
                            );
                            
                            if (playerTileIndex !== -1) {
                                const playerTile = player.tiles[playerTileIndex];
                                
                                // Replace joker with actual tile
                                set.tiles[jokerIndex] = { ...playerTile };
                                player.tiles.splice(playerTileIndex, 1);
                                
                                // Add joker to player's tiles temporarily
                                player.tiles.push(joker);
                                sortPlayerTiles(player);
                                
                                // Try to use the joker immediately
                                let jokerUsed = tryFormNewSetWithJoker(player, joker) || 
                                                tryAddToExistingSetsWithJoker(player, joker);
                                
                                if (jokerUsed) {
                                    updateGameLog(`🃏 ${player.name} replaced a joker with ${playerTile.number}${getColorSymbol(playerTile.color)} and used the joker!`);
                                    return true;
                                } else {
                                    // Couldn't use joker - revert changes
                                    set.tiles[jokerIndex] = joker;
                                    player.tiles = player.tiles.filter(t => t !== joker);
                                    player.tiles.push(playerTile);
                                    sortPlayerTiles(player);
                                }
                            }
                        }
                    }
                }
                
                return false;
            }
            
            // Try to form a new set with a joker (after replacing one)
            function tryFormNewSetWithJoker(player, joker) {
                // Try to form a run with the joker
                for (let i = 0; i < player.tiles.length; i++) {
                    const tile1 = player.tiles[i];
                    if (tile1.isJoker) continue;
                    
                    for (let j = i + 1; j < player.tiles.length; j++) {
                        const tile2 = player.tiles[j];
                        if (tile2.isJoker || tile1.color !== tile2.color) continue;
                        
                        // Check possible positions for joker
                        const numbers = [tile1.number, tile2.number].sort((a, b) => a - b);
                        
                        // Case 1: Joker at the beginning [joker, num1, num2]
                        if (numbers[0] - 1 === numbers[1] - 2) {
                            const newSet = [
                                { ...joker },
                                { ...tile1 },
                                { ...tile2 }
                            ];
                            
                            // Remove tiles from player
                            player.tiles = player.tiles.filter((t, idx) => 
                                idx !== i && idx !== j && t !== joker);
                            
                            // Add to table
                            const setScore = (numbers[0]-1) + numbers[0] + numbers[1];
                            state.tableSets.push({
                                tiles: newSet,
                                type: 'run',
                                owner: player.name,
                                points: setScore
                            });
                            
                            // Update score
                            player.score += setScore;
                            
                            updateGameLog(`${player.name} formed a new run with joker: ${tile1.color} ${numbers[0]-1}-${numbers[0]}-${numbers[1]}`);
                            return true;
                        }
                        
                        // Case 2: Joker in the middle [num1, joker, num2]
                        if (numbers[0] + 1 === numbers[1] - 1) {
                            const newSet = [
                                { ...tile1 },
                                { ...joker },
                                { ...tile2 }
                            ];
                            
                            // Remove tiles from player
                            player.tiles = player.tiles.filter((t, idx) => 
                                idx !== i && idx !== j && t !== joker);
                            
                            // Add to table
                            const setScore = numbers[0] + (numbers[0]+1) + numbers[1];
                            state.tableSets.push({
                                tiles: newSet,
                                type: 'run',
                                owner: player.name,
                                points: setScore
                            });
                            
                            // Update score
                            player.score += setScore;
                            
                            updateGameLog(`${player.name} formed a new run with joker: ${tile1.color} ${numbers[0]}-${numbers[0]+1}-${numbers[1]}`);
                            return true;
                        }
                        
                        // Case 3: Joker at the end [num1, num2, joker]
                        if (numbers[0] + 1 === numbers[1] && numbers[1] + 1 === numbers[1] + 2) {
                            const newSet = [
                                { ...tile1 },
                                { ...tile2 },
                                { ...joker }
                            ];
                            
                            // Remove tiles from player
                            player.tiles = player.tiles.filter((t, idx) => 
                                idx !== i && idx !== j && t !== joker);
                            
                            // Add to table
                            const setScore = numbers[0] + numbers[1] + (numbers[1]+1);
                            state.tableSets.push({
                                tiles: newSet,
                                type: 'run',
                                owner: player.name,
                                points: setScore
                            });
                            
                            // Update score
                            player.score += setScore;
                            
                            updateGameLog(`${player.name} formed a new run with joker: ${tile1.color} ${numbers[0]}-${numbers[1]}-${numbers[1]+1}`);
                            return true;
                        }
                    }
                }
                
                // Try to form a group with the joker
                const groups = {};
                for (let tile of player.tiles) {
                    if (tile.isJoker) continue;
                    if (!groups[tile.number]) {
                        groups[tile.number] = new Set();
                    }
                    groups[tile.number].add(tile.color);
                }
                
                for (let number in groups) {
                    const colors = groups[number];
                    if (colors.size >= 2) {
                        const tilesToUse = [];
                        let color1, color2;
                        for (let color of colors) {
                            if (!color1) {
                                color1 = color;
                                tilesToUse.push(player.tiles.find(t => t.number == number && t.color === color));
                            } else if (!color2) {
                                color2 = color;
                                tilesToUse.push(player.tiles.find(t => t.number == number && t.color === color));
                                break;
                            }
                        }
                        
                        if (tilesToUse.length === 2) {
                            const newSet = [
                                { ...tilesToUse[0] },
                                { ...tilesToUse[1] },
                                { ...joker }
                            ];
                            
                            // Remove tiles from player
                            player.tiles = player.tiles.filter(t => 
                                t !== tilesToUse[0] && t !== tilesToUse[1] && t !== joker);
                            
                            // Add to table
                            const groupScore = number * 3;
                            state.tableSets.push({
                                tiles: newSet,
                                type: 'group',
                                owner: player.name,
                                points: groupScore
                            });
                            
                            // Update score
                            player.score += groupScore;
                            
                            updateGameLog(`${player.name} formed a new group with joker: ${number}'s`);
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            // Try to add to existing sets with a joker
            function tryAddToExistingSetsWithJoker(player, joker) {
                // Simple strategy: try to add joker to an existing set
                for (let set of state.tableSets) {
                    if (set.type === 'run') {
                        // Try to add to the beginning or end of a run
                        const firstTile = set.tiles[0];
                        const lastTile = set.tiles[set.tiles.length - 1];
                        
                        // Try beginning
                        if (joker && firstTile.number > 1) {
                            set.tiles.unshift({ ...joker });
                            player.tiles = player.tiles.filter(t => t !== joker);
                            set.points += firstTile.number - 1;
                            player.score += firstTile.number - 1;
                            updateGameLog(`${player.name} added a joker to the beginning of a run`);
                            return true;
                        }
                        
                        // Try end
                        if (joker && lastTile.number < 13) {
                            set.tiles.push({ ...joker });
                            player.tiles = player.tiles.filter(t => t !== joker);
                            set.points += lastTile.number + 1;
                            player.score += lastTile.number + 1;
                            updateGameLog(`${player.name} added a joker to the end of a run`);
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // AI Strategy to break the ice (30+ points)
            function tryBreakIce(player) {
                let bestSet = null;
                let bestScore = 0;
                let bestType = '';
                
                // Try to find a run of at least 4 tiles for higher points
                for (let i = 0; i < player.tiles.length - 3; i++) {
                    const tile1 = player.tiles[i];
                    if (tile1.isJoker) continue;
                    
                    for (let j = i + 1; j < player.tiles.length - 2; j++) {
                        const tile2 = player.tiles[j];
                        if (tile2.isJoker || tile1.color !== tile2.color) continue;
                        
                        for (let k = j + 1; k < player.tiles.length - 1; k++) {
                            const tile3 = player.tiles[k];
                            if (tile3.isJoker || tile1.color !== tile3.color) continue;
                            
                            // Check for consecutive numbers
                            const numbers = [tile1.number, tile2.number, tile3.number].sort((a, b) => a - b);
                            if (numbers[0] + 1 === numbers[1] && numbers[1] + 1 === numbers[2]) {
                                // Found a run of 3
                                const setScore = numbers[0] + numbers[1] + numbers[2];
                                
                                // Try to extend to 4 tiles if possible
                                let tile4 = null;
                                let setTiles = [tile1, tile2, tile3];
                                
                                for (let l = k + 1; l < player.tiles.length; l++) {
                                    const nextTile = player.tiles[l];
                                    if (nextTile.isJoker || (nextTile.color === tile1.color && 
                                        nextTile.number === numbers[2] + 1)) {
                                        tile4 = nextTile;
                                        setTiles = [tile1, tile2, tile3, tile4];
                                        break;
                                    }
                                }
                                
                                const finalScore = setTiles.reduce((sum, tile) => sum + (tile.isJoker ? numbers[2] + 1 : tile.number), 0);
                                
                                // Check if it meets the icebreaker requirement
                                if (finalScore >= 30 && finalScore > bestScore) {
                                    bestSet = setTiles;
                                    bestScore = finalScore;
                                    bestType = 'run';
                                }
                            }
                        }
                    }
                }
                
                // If we found a qualifying set, play it
                if (bestSet) {
                    // Create a copy of the tiles
                    const newSet = bestSet.map(tile => ({ ...tile }));
                    
                    // Remove tiles from player
                    player.tiles = player.tiles.filter(tile => 
                        !bestSet.some(t => 
                            t.number === tile.number && 
                            t.color === tile.color &&
                            !tile.isJoker) && 
                        !bestSet.some(t => tile.isJoker && t.isJoker)
                    );
                    
                    // Add to table
                    state.tableSets.push({
                        tiles: newSet,
                        type: bestType,
                        owner: player.name,
                        points: bestScore
                    });
                    
                    // Update score
                    player.score += bestScore;
                    
                    updateGameLog(`${player.name} formed an icebreaker run: ${bestScore} points`);
                    return true;
                }
                
                // Try to find a high-value group
                const groups = {};
                for (let tile of player.tiles) {
                    if (tile.isJoker) continue;
                    if (!groups[tile.number]) {
                        groups[tile.number] = [];
                    }
                    groups[tile.number].push(tile);
                }
                
                // Look for a group of 3 or 4 with high numbers
                for (let number = 13; number >= 8; number--) {
                    if (groups[number] && groups[number].length >= 2) {
                        // Check if we have different colors
                        const colors = new Set();
                        const tilesToUse = [];
                        
                        for (let tile of groups[number]) {
                            if (!colors.has(tile.color)) {
                                colors.add(tile.color);
                                tilesToUse.push(tile);
                                if (colors.size === 2) break; // Need at least 3 with joker
                            }
                        }
                        
                        // Check if we have a joker to complete the group
                        const joker = player.tiles.find(t => t.isJoker);
                        if (colors.size >= 2 && joker) {
                            const groupScore = number * 3;
                            if (groupScore >= 30 && groupScore > bestScore) {
                                // Form the group
                                const newSet = tilesToUse.map(tile => ({ ...tile }));
                                newSet.push({ ...joker });
                                
                                // Remove tiles from player
                                player.tiles = player.tiles.filter(tile => 
                                    !tilesToUse.some(t => 
                                        t.number === tile.number && 
                                        t.color === tile.color) &&
                                    tile !== joker
                                );
                                
                                // Add to table
                                state.tableSets.push({
                                    tiles: newSet,
                                    type: 'group',
                                    owner: player.name,
                                    points: groupScore
                                });
                                
                                // Update score
                                player.score += groupScore;
                                
                                updateGameLog(`${player.name} formed an icebreaker group with joker: ${groupScore} points`);
                                return true;
                            }
                        }
                    }
                }
                
                return false;
            }
            
            // AI Strategy functions
            function tryFormNewSet(player) {
                // Try to form a run with joker
                const joker = player.tiles.find(t => t.isJoker);
                if (joker) {
                    for (let i = 0; i < player.tiles.length; i++) {
                        const tile1 = player.tiles[i];
                        if (tile1.isJoker) continue;
                        
                        for (let j = i + 1; j < player.tiles.length; j++) {
                            const tile2 = player.tiles[j];
                            if (tile2.isJoker || tile1.color !== tile2.color) continue;
                            
                            // Check possible positions for joker
                            const numbers = [tile1.number, tile2.number].sort((a, b) => a - b);
                            
                            // Case 1: Joker in the middle [num1, joker, num2]
                            if (numbers[0] + 1 === numbers[1] - 1) {
                                const newSet = [
                                    { ...tile1 },
                                    { ...joker },
                                    { ...tile2 }
                                ];
                                
                                // Remove tiles from player
                                player.tiles = player.tiles.filter((t, idx) => 
                                    idx !== i && idx !== j && t !== joker);
                                
                                // Add to table
                                const setScore = numbers[0] + (numbers[0]+1) + numbers[1];
                                state.tableSets.push({
                                    tiles: newSet,
                                    type: 'run',
                                    owner: player.name,
                                    points: setScore
                                });
                                
                                // Update score
                                player.score += setScore;
                                
                                updateGameLog(`${player.name} formed a new run with joker: ${tile1.color} ${numbers[0]}-${numbers[0]+1}-${numbers[1]}`);
                                return true;
                            }
                        }
                    }
                }
                
                // Simple strategy: try to find 3 consecutive numbers of same color
                for (let i = 0; i < player.tiles.length - 2; i++) {
                    const tile1 = player.tiles[i];
                    if (tile1.isJoker) continue;
                    
                    for (let j = i + 1; j < player.tiles.length - 1; j++) {
                        const tile2 = player.tiles[j];
                        if (tile2.isJoker || tile1.color !== tile2.color) continue;
                        
                        for (let k = j + 1; k < player.tiles.length; k++) {
                            const tile3 = player.tiles[k];
                            if (tile3.isJoker || tile1.color !== tile3.color) continue;
                            
                            // Check for consecutive numbers
                            const numbers = [tile1.number, tile2.number, tile3.number].sort((a, b) => a - b);
                            if (numbers[0] + 1 === numbers[1] && numbers[1] + 1 === numbers[2]) {
                                // Found a run!
                                const newSet = [
                                    { ...tile1 },
                                    { ...tile2 },
                                    { ...tile3 }
                                ];
                                
                                // Remove tiles from player
                                player.tiles = player.tiles.filter((t, idx) => 
                                    idx !== i && idx !== j && idx !== k);
                                
                                // Add to table
                                const setScore = numbers.reduce((sum, num) => sum + num, 0);
                                state.tableSets.push({
                                    tiles: newSet,
                                    type: 'run',
                                    owner: player.name,
                                    points: setScore
                                });
                                
                                // Update score
                                player.score += setScore;
                                
                                updateGameLog(`${player.name} formed a new run: ${tile1.color} ${numbers.join('-')}`);
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            function tryAddToExistingSets(player) {
                // Simple strategy: try to add a tile to an existing set
                for (let set of state.tableSets) {
                    for (let i = 0; i < player.tiles.length; i++) {
                        const tile = player.tiles[i];
                        
                        if (set.type === 'run') {
                            // Try to add to the beginning or end of a run
                            const firstTile = set.tiles[0];
                            const lastTile = set.tiles[set.tiles.length - 1];
                            
                            if (tile.color === firstTile.color && tile.number === firstTile.number - 1) {
                                // Add to beginning
                                set.tiles.unshift({ ...tile });
                                player.tiles.splice(i, 1);
                                set.points += tile.number;
                                player.score += tile.number;
                                updateGameLog(`${player.name} added a tile to the beginning of a run`);
                                return true;
                            }
                            
                            if (tile.color === lastTile.color && tile.number === lastTile.number + 1) {
                                // Add to end
                                set.tiles.push({ ...tile });
                                player.tiles.splice(i, 1);
                                set.points += tile.number;
                                player.score += tile.number;
                                updateGameLog(`${player.name} added a tile to the end of a run`);
                                return true;
                            }
                        }
                    }
                }
                return false;
            }
            
            function tryFormHighGroup(player) {
                // Try to form a group with high numbers (same number, different colors)
                const groups = {};
                
                // Group tiles by number
                for (let tile of player.tiles) {
                    if (tile.isJoker) continue;
                    if (!groups[tile.number]) {
                        groups[tile.number] = [];
                    }
                    groups[tile.number].push(tile);
                }
                
                // Look for a group of 3 or 4 with high numbers
                for (let number = 13; number >= 1; number--) {
                    if (groups[number] && groups[number].length >= 3) {
                        // Check if we have different colors
                        const colors = new Set();
                        const tilesToUse = [];
                        
                        for (let tile of groups[number]) {
                            if (!colors.has(tile.color)) {
                                colors.add(tile.color);
                                tilesToUse.push(tile);
                                if (colors.size === 3) break;
                            }
                        }
                        
                        if (colors.size >= 3) {
                            // Form the group
                            const newSet = tilesToUse.map(tile => ({ ...tile }));
                            
                            // Remove tiles from player
                            player.tiles = player.tiles.filter(tile => 
                                !tilesToUse.some(t => 
                                    t.number === tile.number && 
                                    t.color === tile.color)
                            );
                            
                            // Add to table
                            const groupScore = number * tilesToUse.length;
                            state.tableSets.push({
                                tiles: newSet,
                                type: 'group',
                                owner: player.name,
                                points: groupScore
                            });
                            
                            // Update score
                            player.score += groupScore;
                            
                            updateGameLog(`${player.name} formed a new group of ${number}'s`);
                            return true;
                        }
                    }
                }
                return false;
            }
            
            // End the game and calculate scores
            function endGame() {
                const winner = state.players.find(p => p.tiles.length === 0);
                if (!winner) return;
                
                // Calculate scores
                state.players.forEach(player => {
                    if (player !== winner) {
                        const penalty = player.tiles.reduce((sum, tile) => 
                            sum + (tile.isJoker ? 30 : tile.number), 0);
                        player.score -= penalty;
                        winner.score += penalty;
                    }
                });
                
                updateGameLog(`🏆 ${winner.name} wins with ${winner.score} points! 🏆`);
                updateStatusBar(`Game over! ${winner.name} wins with ${winner.score} points`);
                renderGame();
            }
            
            // Start a new game
            function startNewGame() {
                createDeck();
                shuffleDeck();
                state.gameStarted = true;
                state.currentPlayer = 0;
                state.gameLog = [];
                state.tableSets = [];
                
                // Reset icebreaker status
                state.players.forEach(player => {
                    player.hasBrokenIce = false;
                    player.tiles = [];
                    player.score = 0;
                });
                
                updateGameLog('New game started. Deck shuffled.');
                updateStatusBar('New game started. Deal tiles to begin.');
                renderGame();
            }
            
            // Auto play 5 rounds
            function autoPlay() {
                if (!state.gameStarted) {
                    updateGameLog('Game not started. Please start a new game first.');
                    return;
                }
                
                if (state.autoPlayInterval) {
                    clearInterval(state.autoPlayInterval);
                }
                
                let rounds = 0;
                state.autoPlayInterval = setInterval(() => {
                    simulateMove();
                    rounds++;
                    if (rounds >= 5) {
                        clearInterval(state.autoPlayInterval);
                        updateGameLog('Auto play completed 5 rounds.');
                    }
                }, 1500);
            }
            
            // Reset the game
            function resetGame() {
                if (state.autoPlayInterval) {
                    clearInterval(state.autoPlayInterval);
                }
                initGame();
            }
            
            // Update game log
            function updateGameLog(message) {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                state.gameLog.push({
                    time: timeString,
                    message: message
                });
                
                // Update log display (show latest 15 messages)
                gameLog.innerHTML = state.gameLog.slice(-15).map(entry => 
                    `<div class="log-entry">
                        <span class="log-time">[${entry.time}]</span> ${entry.message}
                    </div>`
                ).join('');
                
                // Scroll to bottom
                gameLog.scrollTop = gameLog.scrollHeight;
            }
            
            // Update status bar
            function updateStatusBar(message) {
                const currentPlayer = state.players[state.currentPlayer];
                const iceStatus = currentPlayer.hasBrokenIce ? 
                    '<span class="icebreaker-indicator">❄️ Ice Broken</span>' : 
                    '<span class="icebreaker-indicator">⚠️ Ice Not Broken</span>';
                
                const jokerStatus = currentPlayer.tiles.some(t => t.isJoker) ?
                    '<span class="joker-indicator">🃏 Has Joker</span>' : '';
                
                statusBar.innerHTML = `${message} ${iceStatus} ${jokerStatus}`;
            }
            
            // Get color symbol
            function getColorSymbol(color) {
                switch(color) {
                    case 'red': return '🔴';
                    case 'blue': return '🔵';
                    case 'yellow': return '🟡';
                    case 'black': return '⚫';
                    default: return '';
                }
            }
            
            // Render the game state
            function renderGame() {
                // Render players
                playerArea.innerHTML = state.players.map((player, index) => {
                    const isCurrent = state.currentPlayer === index;
                    return `
                        <div class="player ${player.hasBrokenIce ? 'ice-broken' : ''} ${isCurrent ? 'current-turn' : ''}">
                            <div class="player-header">
                                <div class="player-name">
                                    ${player.name} ${isCurrent ? '➤' : ''}
                                    ${player.hasBrokenIce ? '<span class="ice-icon">❄️</span>' : ''}
                                </div>
                                <div class="player-score">Score: ${player.score}</div>
                            </div>
                            <div class="tiles">
                                ${player.tiles.map(tile => renderTile(tile)).join('')}
                                ${player.tiles.length === 0 ? '<div class="no-tiles">No tiles left!</div>' : ''}
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Render table sets
                if (state.tableSets.length > 0) {
                    tableSets.innerHTML = state.tableSets.map((set, index) => {
                        const jokerIndex = set.tiles.findIndex(t => t.isJoker);
                        return `
                            <div class="set">
                                <div class="set-header">
                                    <div class="set-title">${set.type} (by ${set.owner})</div>
                                    <div class="set-points">${set.points} pts</div>
                                </div>
                                <div class="set-tiles">
                                    ${set.tiles.map((tile, idx) => {
                                        const tileHtml = renderTile(tile);
                                        if (jokerIndex === idx) {
                                            return `<div style="position:relative;">${tileHtml}<div class="joker-replacement" title="Joker can be replaced">R</div></div>`;
                                        }
                                        return tileHtml;
                                    }).join('')}
                                </div>
                            </div>
                        `;
                    }).join('');
                } else {
                    tableSets.innerHTML = '<div class="no-sets">No sets on the table yet. Players must break the ice first!</div>';
                }
            }
            
            // Render a tile
            function renderTile(tile) {
                if (tile.isJoker) {
                    return `
                        <div class="tile joker">
                            <div class="tile-joker">🃏</div>
                        </div>
                    `;
                }
                
                return `
                    <div class="tile ${tile.color}">
                        <div class="tile-value">${tile.number}</div>
                        <div class="tile-color">${getColorSymbol(tile.color)}</div>
                    </div>
                `;
            }
            
            // Event listeners
            newGameBtn.addEventListener('click', startNewGame);
            dealTilesBtn.addEventListener('click', dealTiles);
            simulateBtn.addEventListener('click', simulateMove);
            autoPlayBtn.addEventListener('click', autoPlay);
            resetBtn.addEventListener('click', resetGame);
            
            // Initialize the game
            initGame();
        });
    </script>
</body>
</html>
